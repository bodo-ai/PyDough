# MetaViewer - Developer Documentation

This document provides a deeper dive into the core data structures and internal workings of the MetaViewer graph visualization component, intended for developers looking to understand or extend the functionality.

## Core Data Structures (`nodes` and `links`)

The heart of the visualization lies in two key arrays generated by `dataProcessor.js`: `nodes` and `links`. These arrays conform to the structure expected by D3.js's force simulation and are used throughout the rendering and interaction logic.

### 1. Node Object Structure

Each element in the `nodes` array represents a collection (table/entity) from the input metadata. Here's a breakdown of its key properties:

- **`id`** (String): Unique identifier for the node, typically the collection name. Used by D3 simulation to link nodes.
- **`name`** (String): Display name for the node (usually same as `id`).
- **`columns`** (Array): List of objects representing table columns/attributes within the collection. Each object typically contains `name`, `columnName`, and `dataType`. Used by `nodeRenderer.js` to display properties.
- **`subcollections`** (Array): List of objects representing relationships originating _from_ this node. Each object details the relationship (`name`, `type`, `target` ID, `singular`, `noCollisions`, `isForward`/`isReverse`, `propertyData`). Used by `nodeRenderer.js` to list outgoing connections and by `dataProcessor.js` to create links.
- **`tablePath`** (String): The source path provided in the metadata. Displayed by `nodeRenderer.js`.
- **`uniqueProperties`** (Array): List of unique property names/combinations. Displayed by `tooltipHandler.js`.
- **`width`, `height`** (Number): Calculated dimensions for the node's visual representation (the rectangle). `width` is currently fixed, while `height` is dynamically calculated by `nodeRenderer.js` (using `calculateNodeHeight`) based on the number of displayed columns and subcollections to ensure content fits. Used by `nodeRenderer.js` and `forceCollide`.
- **`x`, `y`** (Number): _Added/Modified by D3 Simulation_. Current calculated horizontal and vertical position of the node center. Updated on every simulation "tick". `nodeRenderer.js` uses these via the `tick` handler in `graphCreator.js` to set the node group's `transform` attribute.
- **`vx`, `vy`** (Number): _Added/Modified by D3 Simulation_. Current velocity of the node. Used internally by the simulation.
- **`fx`, `fy`** (Number | null): _Set by Drag/Tree Layout_. Fixed position coordinates. If non-null, the simulation will not modify `x` or `y`. `dragHandler.js` sets these on drag end to keep nodes in place. `treeLayout.js` sets these to arrange nodes hierarchically, overriding the force simulation.
- **`treeLevel`** (Number | null): _Set by `treeLayout.js`_. The depth level of the node in the current tree view (0 for the root). Null if not in tree view or not part of the current tree.
- **`treePosition`** (Number | null): _Set by `treeLayout.js`_. The calculated horizontal position within its level in the tree view.
- **`treeParent`** (String | null): _Set by `treeLayout.js`_. The `id` of the parent node in the current tree view hierarchy.

### Understanding Node Position Properties (x/y, fx/fy, vx/vy)

The D3 force simulation adds several properties to each node object in the `nodes` array to manage its position and movement. Understanding their roles is key:

- **`x`, `y` (Current Position):** These represent the node's calculated coordinates at the current simulation tick. The simulation updates these values based on applied forces (links, repulsion, centering, collision) and the node's velocity. The visual position of the SVG node group (`<g class="node">`) is typically updated in the `tick` event handler to match these `x` and `y` values using a `transform="translate(x, y)"` attribute.

- **`vx`, `vy` (Velocity):** These represent the node's current velocity along the x and y axes. The simulation calculates these based on the forces acting on the node. In the next simulation step, the node's `x` and `y` will be updated based on `vx` and `vy` (factoring in simulation constraints like friction/damping). Developers typically don't directly manipulate `vx`/`vy`, but they drive the node's movement during the simulation's settling process.

- **`fx`, `fy` (Fixed Position):** These properties allow you to **fix** a node's position. If `fx` is set to a non-null numerical value, the simulation will **ignore** its own calculations for the node's x-position and velocity (`x`, `vx`) and hold the node's `x` coordinate at the `fx` value. The same applies to `fy` for the y-position. This provides a mechanism to override the simulation's positioning.
  - **Use Case 1 (Dragging):** `dragHandler.js` sets `fx` and `fy` to the node's current `x` and `y` during the drag (`dragstarted`, `dragged`) and keeps them set at the end (`dragended`). This pins the node where the user dropped it.
  - **Use Case 2 (Tree Layout):** `treeLayout.js` calculates specific positions for nodes in the hierarchy and sets their `fx` and `fy` values accordingly. This forces the nodes into the desired tree structure, regardless of the physics simulation forces.

In summary: `x`/`y` show where a node _is_, `vx`/`vy` determine how it's _moving_ according to the simulation, and `fx`/`fy` _override_ the simulation to pin the node in place.

### 2. Link Object Structure

Each element in the `links` array represents a relationship between two collections.

- **`source`** (Object): _Reference_ to the source node object (element from the `nodes` array). D3 simulation uses this reference.
- **`target`** (Object): _Reference_ to the target node object (element from the `nodes` array). D3 simulation uses this reference.
- **`name`** (String): The name of the relationship (property name from the source collection's metadata). Displayed as the link label by `linkRenderer.js`.
- **`type`** (String): The type of relationship (e.g., `simple_join`, `cartesian_product`, `general_join`). Used for styling and potentially by the simulation or renderers.
- **`condition`** (String | null): _Specific to `general_join`_. The join condition string provided in the metadata. Displayed by `tooltipHandler.js`.
- **`singular`** (Boolean): Metadata flag indicating a one-to-one type relationship. Used in tooltips.
- **`noCollisions`** (Boolean): Metadata flag. Used in tooltips.
- **`isForward`** (Boolean): Flag indicating if this link represents a relationship defined directly in the source node's metadata.
- **`isReverse`** (Boolean): Flag indicating if this link represents a reverse relationship added by `dataProcessor.js` for bidirectionality. Used for styling (e.g., dashed lines).
- **`propertyData`** (Object): Reference to the original property data object from the input JSON for this relationship.

_Initial state_: `dataProcessor.js` initially creates links where `source` and `target` might be string IDs. `linkRenderer.js` (or sometimes the simulation setup) resolves these IDs to actual object references before rendering/simulation starts.

## Data Processing Flow (`dataProcessor.js`)

1.  **Node Creation**: Iterates through collections in the raw JSON data. For each collection, it creates a node object, extracting `table_path`, `unique_properties`, processing `properties` into `columns` and `subcollections` (only forward relationships initially). Initial `width` is fixed, and `height` is dynamically calculated by `nodeRenderer.js` (`calculateNodeHeight`) based on content. Initial `x`/`y` positions are often set in a simple grid pattern but are quickly overridden by the simulation.
2.  **Reverse Relationship Processing**: Iterates through all created nodes and their `subcollections`. For each _forward_ relationship found (A -> B) that has a `reverse_relationship_name` defined, it finds the target node (B) and adds a corresponding _reverse_ subcollection (B -> A) to the target node's `subcollections` list, flipping relevant flags (`singular`/`noCollisions`).
3.  **Link Creation**: Iterates through all nodes again. For every relationship listed in a node's `subcollections` (both forward and reverse), it creates a link object, initially setting `source` and `target` to the respective node IDs.

## Rendering Interaction (`graphCreator.js`, `renderers/`)

- `graphCreator.js` receives the `nodes` and `links` arrays.
- It calls `createNodes(g, nodes, ...)` from `nodeRenderer.js`. `nodeRenderer` uses D3's data binding (`.data(nodes).enter().append('g')...`) to create an SVG group (`<g class="node">`) for each node object. Inside this group, it appends SVG elements (`<rect>`, `<text>`, etc.) whose attributes (size, text content) are determined by the bound node data (`d`).
- It calls `createLinks(g, links, nodes)` from `linkRenderer.js`. `linkRenderer` binds the `links` data to create SVG groups (`<g class="link-group">`). Inside, it appends a `<path>` and a `<text>` with `<textPath>`. The path's `d` attribute (defining its shape) is calculated in the simulation `tick` handler based on the `source` and `target` node positions. The `textPath` uses the path to display the link `name`. It references markers defined by `markerRenderer.js` (e.g., `arrowhead-simple_join`, `arrowhead-general_join`).

## Layout Interaction (`graphCreator.js`, `layouts/`)

- `setupForceSimulation(nodes, links, ...)` from `forceLayout.js` initializes the D3 simulation, providing it the `nodes` and `links` arrays. The simulation internally calculates forces and updates the `x`, `y`, `vx`, `vy` properties of each object _in the `nodes` array_ on each simulation step ("tick").
- `graphCreator.js` sets up a listener for the simulation's `"tick"` event: `simulation.on("tick", ticked);`.
- The `ticked` function (within `graphCreator.js`) iterates through the D3 selections of node and link SVG groups.
  - For each node group, it updates the `transform` attribute: `node.attr("transform", d => \`translate(\${d.x}, \${d.y})\`);`. This visually moves the node according to the simulation's calculated `x`, `y`.
  - For each link group's path, it recalculates and updates the `d` attribute based on the _current_ `x`, `y` of its referenced `source` and `target` node objects.
- When `treeLayout.js`'s `createTreeLayout` is called (via `highlightHandler`), it directly modifies the `fx` and `fy` properties of the node objects _in the `nodes` array_. It then restarts the simulation (`simulation.alpha(1).restart()`), forcing it to respect these fixed positions and trigger the `tick` handler to update the SVG positions.

## User Interaction (`graphCreator.js`, `interactions/`)

- Event listeners (`.on("mouseover", ...), .on("click", ...), .call(drag)`) are attached directly to the D3 selections of the SVG elements (e.g., `node` selection from `nodeRenderer`, `link` selection from `linkRenderer`).
- When an event occurs (e.g., mouseover on a node group), the attached handler function receives the event object and, crucially, the data bound to that element (`d`). This `d` is the corresponding object from the `nodes` or `links` array.
- Interaction handlers (e.g., `highlightConnections`, `showNodeTooltip`, `dragstarted`) use this bound data `d` to identify the specific node/link being interacted with (e.g., `d.id`, `d.source.id`).
- Handlers then perform actions like:
  - Adding/removing CSS classes (`.classed("node-highlighted", true)`) to the SVG elements for styling changes.
  - Calling `tooltipHandler` functions with the data `d` to display relevant info (e.g., `showLinkTooltip` includes the `condition` for `general_join` links).
  - Modifying the data object itself (e.g., `dragHandler` setting `d.fx = event.x`).
  - Calling layout functions (e.g., `highlightHandler` calling `createTreeLayout(d)` on click).
  - Modifying simulation state (e.g., `dragHandler` changing `simulation.alphaTarget()`).

## Styling (`styles/graphStyles.js`)

The visual appearance of the graph is controlled by CSS rules injected by `applyGraphStyles()` in `public/js/graph/styles/graphStyles.js`. Key classes include:

- **Nodes:**
  - `.node`: Base styles for the node group.
  - `.node rect`: Styles for the background rectangle.
  - `.node text`: Base text styles.
  - `.node-title`, `.properties-header`, `.column-item`, `.subcollection-item`: Specific text element styles.
  - `.node-highlighted`, `.node-primary`, `.node-faded`: Classes applied during interactions (hover, click, tree view) to modify node appearance (stroke, fill, opacity, font size).
- **Links:**
  - `.link-group`: Container for path and label.
  - `.link`: Base styles for the path element.
  - `.link-forward`, `.link-reverse`, `.link-cartesian_product`, `.link-general_join`: Type-specific path styles (stroke color, dasharray). `general_join` typically uses an orange stroke (`#ff7f0e`).
  - `.link-highlighted`: Applied on hover/tree view, usually changing stroke color (dark green) and width.
  - `.link-label`: Styles for the text label on the link.
  - `.link-label-forward`, `.link-label-reverse`: Color for labels based on direction.
  - `.link-label-highlighted`: Applied on hover/tree view, changing fill color and font size.
- **Markers:**
  - `.arrowhead`: Base style for arrowheads.
  - `.arrowhead-cartesian_product`, `.arrowhead-general_join`: Type-specific fill colors (purple, orange).
  - `.arrowhead-highlighted`: Fill color for highlighted state (dark green).
- **Tooltips:**
  - `.tooltip`: Main tooltip container styles.
  - `.tooltip-title`, `.tooltip-table`, `.tooltip-label`, etc.: Styles for internal tooltip elements.

The key takeaway is the central role of the `nodes` and `links` arrays. They hold the state, are manipulated by the simulation and layouts, drive the rendering process, and provide context to interaction handlers via D3's data binding.
